Content
-------
TODO

The book has not been proofreaded! There are probably many typos and many language mistakes (my apologies!).

TODO What you should know.

To really benefit from reading this book you should:

* have some experience in writing tests, especially unit tests,
* know a testing framework; preferably TestNG, but any other will also be fine (but you have to scan TestNG documentation to understand code samples),
* be interested in improving your tests-writing skills,
* understand the value of clean test code.

The source I recommend is my book (well, of course!) but to be honest you can learn most of it by doing a research on your own (web has it all, but you have to find it first!).

TODO about +setUp()+ what I mean by this

== Why Bother?
* does it work?
* changes
* documentation
* quality

== Introduction
I would like to start our journey through various tests by going few years back. The tests discussed in this section were written in years 2004-2006. They were never a part of any serious test harness (i.e. no regular execution on CI server).

Cast the first stone...
The reason we look at these tests is not to have a laugh at developers who have written them. I do not doubt they did the best they could. I wonder myself wheter in 2004 I was able to write better tests, or even whether I was able to write any tests at all... There are two reasons I discuss these ancient tests. Firstly, let us see how much more educated and experienced we (as a community of developers) are in the area of tests. Secondly, there is much to learn even from such imperfect tests.

From the dark ages of testing - tests provided by Bartosz.

Conclusions:

* it is an everyday effort,
** (vs. follow the leader, and commented out smoke test)
* do not generate, write them!,
* master your tools (or at least learn the basics),
* they should inform about the reason they failed.

== Autogeneration

----
public void testSetGetTimestamp() throws Exception {
    // JUnitDoclet begin method setTimestamp getTimestamp
    java.util.Calendar[] tests = {new GregorianCalendar(), null};

    for (int i = 0; i < tests.length; i++) {
    	adapter.setTimestamp(tests[i]);
    	assertEquals(tests[i], adapter.getTimestamp());
    }
    // JUnitDoclet end method setTimestamp getTimestamp
}

public void testSetGetParam() throws Exception {
    // JUnitDoclet begin method setParam getParam
    String[] tests = {"a", "aaa", "---", "23121313", "", null};

    for (int i = 0; i < tests.length; i++) {
    	adapter.setParam(tests[i]);
    	assertEquals(tests[i], adapter.getParam());
    }
    // JUnitDoclet end method setParam getParam
}
----

== Flickering Tests
Flickering tests are a serious disease which can be very hard to cure. Once you caught it you can spend days trying to figure out what is going on. One time your tests are [green]#green#, next time they are [red]#red#, then everything is back to normal, but after some time the situation repeats - without any code changes which could possibly cause such result!

This can really turn your hair grey! Usually, such indeterministic behaviour is related to some external systems your tests rely on. Perhaps some 3rd party webservice goes bananas from time to time and responds with nonsensical data. Or maybe there is some subtle bug in the time-related logic of your system which makes your test fail occasionally. 

But sometimes it is our lack of thoughtfullness which can bring that doom on ourselves. At least its mild form - a test which suddenly turns from [green]#green# to [red]#red# without any significant code change (and probably stays like this, which makes it much simpler to debug than the real flickering test).

Let us have a look at the following example. The test presented below verifies whether log4j{empty}pass:[]footnote:[http://logging.apache.org/log4j/] configuration code works fine. If some system property (+logConfig+) is available, it should load file specified by this property. If the property is not set it should load some default values.

----
LoggingPropertyConfigurator configurator 
    = mock(LoggingPropertyConfigurator.class);
BaseServletContextListener baseServletContextListener 
    = new BaseServletContextListener(configurator);

@Test public void shouldLoadDefaultProperties() {
    baseServletContextListener.contextInitialized(null);
    verify(configurator).configure(any(Properties.class));
}

@Test(expected = LoggingInitialisationException.class)
public void shouldThrowLoggingException() {
    System.setProperty("logConfig", "nonExistingFile");
    baseServletContextListener.contextInitialized(null);
}
----
This test used to be [green]#green# for months. Then, suddenly, it turned [red]#red#. Why?! For no apparent reason, the log4j config was not something we changed often. In fact, we haven't touched it for a long time... The reason was, that this test relied on the order of execution. As long as +shouldLoadDefaultProperties+ was executed before +shouldThrowLoggingException+ everything was fine. But once this order was changed, things started to go wrong. In particular, the +logConfig+ system property was available in when +shouldLoadDefaultProperties+ test was executed, which altered the behaviour of SUT and made this test fail.

And why did the order of execution changed? Well, it does not really matter. In general test frameworks do not guarantee the order of execution (unless you explicitely ask for it) so you should not rely on this.

Now, how to fix it. Basically there are two solutions:
* clean +logConfig+ system property variable before +shouldLoadDefaultProperties+ is executed (if you have more test here then maybe putting this into some +setUp()+ method would be a good idea),
* or imopse strict order of execution of these two test methods (TestNG will allow you to do this, JUnit won't).

== Mock'em All!
TODO use the front door

----
@Test
public void shouldAddTimeZoneToModelAndView() {
	//given
	UserFacade userFacade = mock(UserFacade.class);
	ModelAndView modelAndView = mock(ModelAndView.class);
	given(userFacade.getTimezone()).willReturn("timezone X");

	//when
	new UserDataInterceptor(userFacade)
		.postHandle(null, null, null, modelAndView);

	//then
	verify(modelAndView).addObject("timezone", "timezone X"); 
}
----

== Time Means Troubles (Always!)

----
public String getZendeskUrl(User user, String timestamp) {
	String name=user.getFullName();

	String url=baseUrl
		+"name="+URLEncoder.encode(name, "UTF-8")
		+"&timestamp="+timestamp;
	return url;
}

public String getZendeskUrl(User user) {
	Date date=new Date();
	Long time=(date.getTime()/1000); //convert ms to seconds
	String timestamp=time.toString();
	return getZendeskUrl(user, timestamp);
}
----

== TODO SRP for Tests
We are all familiar with Single Responsibility Principle{empty}pass:[]footnote:[SRP, see http://en.wikipedia.org/wiki/Single_responsibility_principle], which basically says that every class should take care of one thing. I think it is very valuable to think about tests in terms of SRP. In case of tests, each test method should conform to the following rule: '"Each test method should verify one scenario"'.

Why? Because:

* such test methods are pretty simple to understand,
* if they fail you know *exactly* which functionality of your software does not work.

Keeping to this SRP for tests is very simple for unit tests, but not always applicable for other kind of tests.

Still, I observe it being breached frequently. Let us have a look at an example. It comes from a simple utility class, which was responsible for making sure that the phone prefix entered by users are valid.

----
@DataProvider
public Object[][] data() {
  return new Object[][] {
    {"48", true}, {"+48", true}, {"++48", true}, 
    {"+48503", true}, {"+4", false}, {"++4", false},
    {"", false}, {null, false}, {"  ", false}, };
}

@Test(dataProvider = "data")
public void testQueryVerification(String query, boolean expected) {
    assertEquals(expected, FieldVerifier.isValidQuery(query));
}
----
At the first sight, it may seem like the test is really focused on one thing (on the verification of query validity), but if you look closer you will see some alarming signals:

* its method name is quite generic, and it would be hard to use a '"should"' prefix (see <<sec_should>>),
* it has some kind of logic: assertions depends on passed +boolean+ flag (see <<sec_no_logic>>).

[[sec_no_logic]]
== Logic in Tests
TODO

== Happy Path
TODO

== Naming is the King
TODO

* user_1
* domain1
* do not make me learn the API
  * statics
  * builders

[[sec_should]]
=== Should is Better than Test
* the names of test methods

== Avoid Private Methods
* assertions
* setup

== Excessive SetUp
TODO merge with previous one?

== Things to Remember

* Single Responsibility Principle for tests
* Names are important!
* Test behaviour, not methods!
* Ask yourself "what is the purpose of this test?", "what is really important?"
* Think about readability (just say it)
* Test-last does not work

== Know Your Tool
TODO

== Randomness
TODO

== Help
Send me your tests!

== TODO Book Teaser
TODO

TODO cover img

http://practicalunittesting.com
